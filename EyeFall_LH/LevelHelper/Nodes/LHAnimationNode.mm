//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHSettings.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHAnimationNode (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHAnimationNode
@synthesize loop;
@synthesize speed;
@synthesize repetitions;
@synthesize startAtLaunch;
////////////////////////////////////////////////////////////////////////////////
-(void) dealloc{		
    
    NSLog(@"LH Animation Dealloc");
    
    [uniqueName release];
    [frames release];
	[super dealloc];
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithUniqueName:(NSString *)name{
    self = [super init];
    if (self != nil)
    {
        uniqueName = [[NSMutableString alloc] initWithString:name];
        frames = [[NSMutableArray alloc] init];
        batchNode = nil;
        speed = 0.2f;
        repetitions = 1;
        loop = false;
    }
    return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) animationNodeWithUniqueName:(NSString*)name{
    return [[[self alloc] initWithUniqueName:name] autorelease];
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");

    [uniqueName setString:name];
}
-(NSString*)uniqueName{
    return uniqueName;   
}
////////////////////////////////////////////////////////////////////////////////
-(void) setFrames:(NSArray*)frms{
    [frames removeAllObjects];
    [frames addObjectsFromArray:frms];
}
////////////////////////////////////////////////////////////////////////////////
-(void) setBatchNode:(CCSpriteBatchNode*)node{
    batchNode = node;
}
////////////////////////////////////////////////////////////////////////////////
-(void) runAnimationOnSprite:(LHSprite*)ccsprite 
             withNotifierObj:(id)animNotifierId 
                 notifierSel:(SEL)animNotifierSel
                 notifOnLoop:(bool)notifOnLoop
{
    CCAnimation *anim = [CCAnimation animationWithFrames:frames delay:speed];
    
    CCFiniteTimeAction *seq;
    if(!loop)
    {
        id animAct = [CCRepeat actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                          restoreOriginalFrame:NO] 
                                          times:repetitions];
        
        if(nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:uniqueName];
            seq = [CCSequence actionOne:animAct two:actionRestart];
        }
        else
        {
            seq = [CCSequence actions:animAct, nil];
        }
    }
    else
    {
        if(notifOnLoop && nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:uniqueName];
            
            id animAct = [CCSequence actionOne:[CCAnimate actionWithAnimation:anim 
                                                         restoreOriginalFrame:NO] 
                                           two:actionRestart];
            
            seq = [CCRepeatForever actionWithAction:animAct];
        }
        else
        {
            seq = [CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                              restoreOriginalFrame:NO]];
        }
    }
    
    [seq setTag:LH_ANIM_ACTION_TAG];

    if(seq != nil)
    {
        [ccsprite setAnimation:self];
        [self setAnimationTexturePropertiesOnSprite:ccsprite];
        [ccsprite runAction:seq];    
    }
}
////////////////////////////////////////////////////////////////////////////////
-(int) numberOfFrames{
    return [frames count];
}
////////////////////////////////////////////////////////////////////////////////
-(void) setAnimationTexturePropertiesOnSprite:(LHSprite*)ccsprite
{
    [ccsprite removeFromParentAndCleanup:YES];
    
    [ccsprite setTexture:[batchNode texture]];
    [ccsprite setBatchNode:batchNode];
    [batchNode addChild:ccsprite];
    
}
-(void) setFrame:(int)frameNo onSprite:(LHSprite*)spr{
    
    if(nil == spr)
        return;
    
    if(frameNo >= 0 && frameNo < [frames count])
    {
        CCSpriteFrame* frame = [frames objectAtIndex:frameNo];
    
        if(nil != frame)
        {
            [spr setTextureRect:[frame rect]];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
@end
