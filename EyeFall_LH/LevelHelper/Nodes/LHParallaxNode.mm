//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHParallaxNode.h"
#import "LHSettings.h"
#import "LHSprite.h"
////////////////////////////////////////////////////////////////////////////////
@interface LHParallaxPointObject : NSObject
{
	CGPoint position;
	CGPoint	ratio;
	CGPoint offset;
	CGPoint initialPosition;
	CCNode *ccsprite;	//weak ref
	b2Body *body;		//weak ref
}
@property (readwrite) CGPoint ratio;
@property (readwrite) CGPoint offset;
@property (readwrite) CGPoint initialPosition;
@property (readwrite) CGPoint position;
@property (readwrite,assign) CCNode *ccsprite;
@property (readwrite,assign) b2Body *body;

+(id) pointWithCGPoint:(CGPoint)point;
-(id) initWithCGPoint:(CGPoint)point;
@end

@implementation LHParallaxPointObject
@synthesize ratio;
@synthesize initialPosition;
@synthesize offset;
@synthesize position;
@synthesize ccsprite;
@synthesize body;

-(void) dealloc{
	
	//NSLog(@"LH PARALLAX POINT OBJ DEALLOC");
	[super dealloc];
}
+(id) pointWithCGPoint:(CGPoint)_ratio{
	return [[[self alloc] initWithCGPoint:_ratio] autorelease];
}
-(id) initWithCGPoint:(CGPoint)_ratio{
	if( (self=[super init])) {
		ratio = _ratio;
	}
	return self;
}
@end

////////////////////////////////////////////////////////////////////////////////
@interface LHParallaxNode (Private)

@end

@implementation LHParallaxNode

@synthesize isContinuous;
@synthesize direction;
@synthesize speed;

-(void) dealloc{	
	
	//NSLog(@"LHParallaxNode DEALLOC");
	[sprites release];
	[super dealloc];
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithDictionary:(NSDictionary*)parallaxDict;
{
	if( (self=[super init])) {

		sprites = [[NSMutableArray alloc] init];
		isContinuous = [[parallaxDict objectForKey:@"ContinuousScrolling"] boolValue];
		direction = [[parallaxDict objectForKey:@"Direction"] intValue];
		speed = [[parallaxDict objectForKey:@"Speed"] floatValue];
		lastPosition = CGPointMake(-100,-100);
	
		winSize = [[CCDirector sharedDirector] winSize];
		screenNumberOnTheRight = 1;
		screenNumberOnTheLeft = 0;
		screenNumberOnTheTop = 0;
		if(!isContinuous)
			speed = 1.0f;
	}
	return self;
}
////////////////////////////////////////////////////////////////////////////////
+(id) nodeWithDictionary:(NSDictionary*)properties
{
	return [[[self alloc] initWithDictionary:properties] autorelease];
}
//////////////////////////////////////////////////////////////////////////////////
-(void) addChild:(LHSprite*)sprite 
   parallaxRatio:(CGPoint)ratio
{
	NSAssert( sprite != NULL, @"Argument must be non-nil");
	
	LHParallaxPointObject *obj = [LHParallaxPointObject pointWithCGPoint:ratio];
	obj.ccsprite = sprite;
	obj.body = [sprite body];
	obj.position = [sprite position];
	obj.offset = [sprite position];
	obj.initialPosition = [sprite position];
	[sprites addObject:obj];
	
	
	int scrRight = (int)(obj.initialPosition.x/winSize.width);
	
	if(screenNumberOnTheRight <= scrRight)
		screenNumberOnTheRight = scrRight+1;
		
	int scrLeft = (int)(obj.initialPosition.x/winSize.width);
    
	if(screenNumberOnTheLeft >= scrLeft)
		screenNumberOnTheLeft = scrLeft-1;

    
	int scrTop = (int)(obj.initialPosition.y/winSize.height);
	
	if(screenNumberOnTheTop <= scrTop)
		screenNumberOnTheTop = scrTop + 1;
	
	int scrBottom = (int)(obj.initialPosition.y/winSize.height);

	if(screenNumberOnTheBottom >= scrBottom)
		screenNumberOnTheBottom = scrBottom-1;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*)spritesInNode{
	
	NSMutableArray* sprs = [[[NSMutableArray alloc] init] autorelease];
	for(LHParallaxPointObject* pt in sprites)
	{
		if(pt.ccsprite != nil)
			[sprs addObject:pt.ccsprite];
	}
	
	return sprs;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*)bodiesInNode
{
	NSMutableArray* sprs = [[[NSMutableArray alloc] init] autorelease];
	for(LHParallaxPointObject* pt in sprites)
	{
		if(0 != pt.body)
			[sprs addObject:[NSValue valueWithPointer:pt.body]];
	}	
			 
	return sprs;
}
////////////////////////////////////////////////////////////////////////////////
-(void) setPosition:(CGPoint)pos onPoint:(LHParallaxPointObject*)point
{
	if(point.ccsprite != nil && point.body == NULL){
		point.ccsprite.position = pos;
	}
	else if(point.body != NULL){
		
		float angle = [point.ccsprite rotation];
		point.body->SetTransform(b2Vec2(pos.x/[[LHSettings sharedInstance] lhPtmRatio], 
										pos.y/[[LHSettings sharedInstance] lhPtmRatio]), 
										CC_DEGREES_TO_RADIANS(-angle));
	}
}
////////////////////////////////////////////////////////////////////////////////
-(void)repositionPoint:(LHParallaxPointObject*)point
{
	CGSize contentSize = [point.ccsprite contentSize];
	float scaleX = [point.ccsprite scaleX];
	float scaleY = [point.ccsprite scaleY];
	
	switch (direction) {
		case 1: //right to left
		{
			if(point.ccsprite.position.x + contentSize.width/2.0f*scaleX <= 0)
			{
				float difX = point.ccsprite.position.x + contentSize.width/2.0f*scaleX;
		
				[point setOffset:ccp(winSize.width*screenNumberOnTheRight - point.ratio.x*speed -  contentSize.width/2.0f*scaleX + difX, point.offset.y)];
				
			}
		}	
			break;
			
		case 0://left to right
		{
			if(point.ccsprite.position.x - contentSize.width/2.0f*scaleX >= winSize.width)
			{
				float difX = point.ccsprite.position.x - contentSize.width/2.0f*scaleX - winSize.width;
				
				[point setOffset:ccp(winSize.width*screenNumberOnTheLeft + point.ratio.x*speed +  contentSize.width/2.0f*scaleX + difX, point.offset.y)];
			}
		}
			break;
			
		case 2://up to bottom
		{
			if(point.ccsprite.position.y + contentSize.height/2.0f*scaleY <= 0)
			{
				float difY = point.ccsprite.position.y + contentSize.height/2.0f*scaleY;
				
				[point setOffset:ccp(point.offset.x, winSize.height*screenNumberOnTheTop - point.ratio.y*speed - contentSize.height/2.0f*scaleY + difY)];
				
			}
		}
			break;
			
		case 3://bottom to top
		{
			if(point.ccsprite.position.y - contentSize.height/2.0f*scaleY >= winSize.height)
			{
				float difY = point.ccsprite.position.y - contentSize.height/2.0f*scaleY - winSize.height;
				
				[point setOffset:ccp(point.offset.x, winSize.height*screenNumberOnTheBottom + point.ratio.y*speed + contentSize.height/2.0f*scaleY + difY)];
				
			}
		}
			break;
		default:
			break;
	}
}
////////////////////////////////////////////////////////////////////////////////
-(void)visit
{
	CGPoint pos = [self position];
	if( ! CGPointEqualToPoint(pos, lastPosition) || isContinuous) 
	{
		for(LHParallaxPointObject *point in sprites)
		{
						
			float x = pos.x * point.ratio.x + point.offset.x;
			float y = pos.y * point.ratio.y + point.offset.y;	
			
			[self setPosition:CGPointMake(x, y) onPoint:point];	
			
			if(isContinuous)
			{
				int i = 1; //direction left to right //bottom to up
				if(direction == 1 || direction == 2) //right to left //up to bottom
					i = -1;

				[self repositionPoint:point];
			
				[point setOffset:ccp(point.offset.x + i*point.ratio.x*speed, 
									 point.offset.y + i*point.ratio.y*speed)];

			}
		}
		lastPosition = pos;
	}
	[super visit];
}
				   
@end
